/* 1  Создать имплементацию функции `forEach`, логика работы 
такая же как и у родного метода.
Функция должна содержать проверки:
- Первый параметр обязателен и может принимать только массив
- Второй параметр обязателен и может принимать только функцию*/

const arr = [1,2,3];
forEach(arr, function(item, i, arr) {
	console.log('a[' + i + '] = ' + item + ' array :' + arr);
});

function forEach(arr) {
	arr.map(function(num) {console.log(num)})
}

arr.forEach(function(item, i, arr))

/*
function logArrayElements(element, index, array) {
  console.log('a[' + index + '] = ' + element);
}

const arr = [1,2,3];

function forEach(arr, logArrayElements) {
	arr.map(function(num){
		logArrayElements(num)
	})
}

forEach(arr, logArrayElements)

arr.map(function(num) {
  console.log("Задание 1.   item : " + num + " index : " + arr.indexOf(num) + " array : " + arr)
});



// Обратите внимание на пропуск по индексу 2, там нет элемента, поэтому он не посещается
[2, 5, , 9].forEach(logArrayElements);
// логи:
// a[0] = 2
// a[1] = 5
// a[3] = 9*/

/*2 Создать имплементацию функции `filter`, логика работы 
такая же как и у родного метода.
Функция должна содержать проверки:
- Первый параметр обязателен и может принимать только массив
- Второй параметр обязателен и может принимать только функцию*/

const arr2 = [1,2,3];
//filter(arr2, function(item, i, arr) {});

/*3 Создать имплементацию функции `every`, логика работы 
такая же как и у родного метода.
Функция должна содержать проверки:
- Первый параметр обязателен и может принимать только массив
- Второй параметр обязателен и может принимать только функцию*/

const arr3 = [1,2,3];
//every(arr3, function(item, i, arr) {});

/*4 Создать имплементацию функции `some`, логика работы 
такая же как и у родного метода.
Функция должна содержать проверки:
- Первый параметр обязателен и может принимать только массив
- Второй параметр обязателен и может принимать только функцию*/

const arr4 = [1,2,3];
//some(arr4, function(item, i, arr) {});

/*5 Создать имплементацию функции `reduce`, логика работы 
такая же как и у родного метода.
Функция должна содержать проверки:
- Первый параметр обязателен и может принимать только массив
- Второй параметр обязателен и может принимать только функцию
- Третий параметр обязателен и может принимать только строку 
или число*/

const arr5 = [1,2,3];
const acc5 = 0;
//reduce(arr5, function(acc, item, i, arr) {}, acc);

/*6 Создать имплементацию функции `reduceRight`, логика работы 
такая же как и у родного метода.
Функция должна содержать проверки:
- Первый параметр обязателен и может принимать только массив
- Второй параметр обязателен и может принимать только функцию
- Третий параметр обязателен и может принимать только строку 
или число*/

const arr6 = [1,2,3];
const acc6 = 0;
arr6.reduceRight(arr6, function(acc, item, i, arr) {}, acc6);

/*7 Код ниже получает из массива строк новый массив, 
содержащий их длины:*/

var arr7 = ['abcd', 'abcde', 'ab', 'abc'];

var arrLength = [];
for (var i = 0; i < arr7.length; i++) {
arrLength[i] = arr7[i].length;
}

console.log( arrLength ); // 4,5,2,3

/*Перепишите выделенный участок:
- используйте вместо цикла `for` метод `map`*/

var arr7Length = arr7.map(function(num) {
  return num.length;
});
console.log("Задание 7 :" + arr7Length );

/*8 Напишите функцию `f` . Данная функция принимает один параметр: 
одноуровневый или многоуровневый массив. Возвращает данная функция 
сумму всех элементов на всех уровнях.
Обратите внимание что функция должна возвращать число 0, 
если при проходе всех уровней не было найдено ни одного числа.
Функция должна содержать проверки:
- Первый параметр обязателен и может принимать только массив
- Генерировать ошибку если на каком то уровне было найдено не 
число и не массив*/
function f(arr) {
	var summa = 0; 
	if (Array.isArray(arr)) {
		sum(arr);
		function sum(arr) {arr.map(function(num){
			if (typeof(num) == "number") summa += num;
			else 
			if (Array.isArray(num)) sum(num);
			else console.log("элемент " + num + " не является числом или массивом") 
			})
		}	
	}
	else console.log("полученный аргумент не является массивом");
	return summa
}
const arr8 = [[[1, 2], [1, 2]], [[2, 1], [1, 2]]];
console.log("Задание 8 :" + f(arr8)); // 12
const arr82 = [[[[[1,2]]]]];
console.log("Задание 8 :" + f(arr82)); // 3
const arr83 = [[[[[1,2]]],2],1];
console.log("Задание 8 :" + f(arr83)); // 6
const arr84 = [[[[[]]]]];
console.log("Задание 8 :" + f(arr84)); // 0
const arr85 = [[[[[],3]]]];
console.log("Задание 8 :" + f(arr85)); // 3 

/*9 Сделайте функцию `arrayFill`, которая будет заполнять массив 
заданными значениями. Первым параметром функция принимает значение,
которым заполнять массив, а вторым — сколько элементов должно быть 
в массиве.
Функция должна содержать проверки:
- Первый параметр обязателен и может принимать только число, 
строку, объект, массив
- Второй параметр обязателен и может принимать только число*/

function getClass(obj) {
  return {}.toString.call(obj).slice(8, -1);
}

function arrayFill(arg, num) {
	if (typeof arg != "number" && typeof arg != "string" && getClass(arg) != "object" && getClass(arg) != "array" || typeof arg == "undefined") {return "неверный первый параметр"}
		else
			if (typeof num != "number" || typeof num == "undefined") 
				{return "неверный второй параметр"}
			else {
				var arr9 = Array(num);
				return arr9.fill(arg, 0, num);
			}
}
console.log("Задание 9 :" + arrayFill('x', 5)) ; // [x,x,x,x,x]

/*10 Создать имплементацию функции `reverse`, которая принимает 
массив в качестве параметра, а возвращает массив только в 
обратном порядке.
Функция должна содержать проверки:
- Первый параметр обязателен и может принимать только массив
- Генерировать ошибку если был передан пустой массив*/

function reverse(arg) {
	var arr11 = Array();
	if (getClass(arg) != "Array" || typeof arg == "undefined") {return "неверный первый параметр"}
		else arg.map(function(num){
			var index = arg.indexOf(num);
			var indexNew = (arg.length-1) - index;
			arr11[indexNew] = num;
		})
			return arr11;
}


const arr10 = [5,4,3,2,1];
console.log("Задание 10 :" + reverse(arr10)); // [1,2,3]